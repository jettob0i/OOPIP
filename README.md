# Не сдана только 7-ая лаба.

WindowsProject3 - консольное приложение Windows, 6-ая лаба, необходима для работы 7-ой лабы.
ConsoleApplication4 - код самой 7-ой лабы.

Из-за того, что GitHub не дает загрузить основной файл (ConsoleApplication4), то я закинул его на платформу OneDrive (ссылка ниже)
https://1drv.ms/f/s!AgLRl5i9yERW3Qfw3fjwEnPkiHGk?e=Lw87lT

Условия 7-ой лабы:
Часть 1
Программу, разработанную в лабораторной работе No 6, преобразовать
следующим образом: для обеспечения движения геометрических фигур в окне
вместо таймера использовать потоки. Для каждой геометрической фигуры
использовать свой поток. Потоковая функция должна быть одна, объект
«Фигура» передается в потоковую функцию через параметр (для передачи
дополнительных данных в потоковую функцию в качестве параметра можно
задать указатель на структуру). При необходимости использовать
синхронизацию.
Часть 2
Необходимо обеспечить синхронизацию двух приложений.
Первое приложение. Приложение с потоками преобразовать так, чтобы
движение фигур в потоках начиналось не сразу, а после получения сигнала от
второго приложения. При получения сигнала потоки начинают работать до тех
пор, пока от второго приложения не придет другой сигнал, при получении
второго сигнала потоки завершают свою работу.
Второе приложение – консольное приложение Windows (запускается
только при запущенном первом приложении). После нажатия клавиши
посылается сигнал для начала работы потоков в первом приложении. После
следующего нажатия клавиши посылается сигнал на завершение работы потоков
в первом приложении.
Продемонстрировать совместную работу двух приложений.

Алгоритм действия по шагам:
1. Подключить необходимые заголовочные файлы.
2. Создать переменную типа HANDLE для хранения дескриптора события.
3. Установить локаль в кириллическую с помощью функции setlocale.
4. Открыть событие с помощью функции OpenEvent, указав EVENT_ALL_ACCESS для доступа на запись и чтение, TRUE для автосброса события и строку L"MyEventl" в качестве имени события.
5. Проверить успешность открытия события, если не удалось, вывести сообщение об ошибке, завершить выполнение программы и вернуть 0.
6. Вывести сообщение о необходимости нажатия любой клавиши для запуска потоков в другом приложении.
7. Дождаться нажатия клавиши с помощью функции _getch.
8. Установить событие в сигнальное состояние с помощью функции SetEvent для запуска потоков в другом приложении.
9. Вывести сообщение о необходимости нажатия любой клавиши для завершения потоков в другом приложении.
10. Дождаться нажатия клавиши с помощью функции _getch.
11. Сбросить событие в несигнальное состояние с помощью функции ResetEvent для завершения потоков в другом приложении.
12. Вывести сообщение о необходимости нажатия любой клавиши для выхода из приложения.
13. Дождаться нажатия клавиши с помощью функции _getch.
14. Завершить работу программы и вернуть 0.
15. Переходим в окно кода WindowsProject3 и выполняем следующие действия:
16.Объявляем переменную hEvent типа HANDLE и структуру ForThread с полями pFig и hEvent.
17. Объявляем массив hEvents размером 3, массив pF размером 3 и массив Data размером 3, заполняем его значениями.
18. Инициализируем переменную flag значением 1.
19. Создаем три объекта класса Figure, соответствующих элементам массива pF.
20. Для каждого элемента массива Data задаем значения полей pFig и hEvent.
21. Создаем три системных объекта событий и записываем их в массив hEvents.
22. Создаем три потока, каждому передаем соответствующие элементы массивов pF и hEvents.
23. В цикле ожидаем завершения всех трех потоков.
24. При получении уведомления об окончании работы потока устанавливаем флаг в соответствующий элемент массива Data, связанный с завершившимся потоком.
25. Если все три потока завершили работу, то освобождаем системные объекты событий, объекты Figure и завершаем программу.
26. Создание структуры данных Data в "LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)", которая содержит указатель на фигуру pF и дескриптор события hEvent. Также создаются массив из нескольких дескрипторов событий hEvents и выделяются потоки. 
27. Для каждой итерации цикла i объявляются переменные pFig и hEvent равными текущим значениям в массивах pF и hEvents[i] соответственно. 
28. Создание события с помощью функции CreateEvent с начальным значением “несигнальное, мануальное сброс и без защиты”. 
29. Создание потока с помощью функции CreateThread и передача ему функции ThreadFun, указателя на текущий элемент Data[i] и дополнительных параметров.
30. Повторение цикла для каждого элемента массива. 
31. Выход из функции после завершения выполнения всех потоков.
